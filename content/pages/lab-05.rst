:title: Lab 5: Drone Flight Control
:status: hidden
:slug: lab-05

.. contents::

Learning Objectives
===================

After completing this lab you will be able to:

- derive the equations of motion for longitudinal drone flight dynamics
- formulate the explicit first order ordinary differential equations for the
  system
- translate ordinary differential equations into a computer function that
  evaluates the equations at any given point in time
- develop a function that evaluates state dependent input functions
- develop a function that evaluates state and input dependent output variables
- numerically integrate ordinary differential equations with Octave/Matlab's
  ode45_
- create complete and legible plots of the resulting input, state, and output
  trajectories
- create a report with textual explanations and plots of the simulation
- design a PID controller that stabilizes the drone in pitch and tracks a path

.. _ode45: https://www.mathworks.com/help/matlab/ref/ode45.html

.. topic:: Information
   :class: alert alert-info

   Extra information (asides) are in blue boxes.

.. topic:: Warnings
   :class: alert alert-warning

   Warnings are in yellow boxes.

Introduction
============

In this lab, you will investigate the longitudinal (altitude and pitch) flight
dynamics of a quadcopter traveling at a constant forward speed. This vehicle
relies completely on the independently controlled thrust generated by pairs of
rotors at the front and rear of the vehicle to change altitude and its pitch
orientation. The vehicle is very much unstable and requires controllers to
maintain a desired pitch angle and to control altitude. The following video
shows an autonomous quadcopter that can avoid obstacles using a combination of
vision detection to determine relative locations of the obstacles and a
feedback controller to avoid the obstacles given the computed desired path of
motion. You will develop the feedback controller portion of a system like the
one shown.

.. raw:: html

   <iframe width="560" height="315"
   src="https://www.youtube.com/embed/BzykucxFddI" frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope;
   picture-in-picture" allowfullscreen></iframe>

Here is another similar system using a fixed wing autonomous aircraft at higher
speeds:

.. raw:: html

   <iframe width="560" height="315"
   src="https://www.youtube.com/embed/_qah8oIzCwk" frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope;
   picture-in-picture" allowfullscreen></iframe>

System Description
==================

You will model the longitudinal dynamics of a drone flying at a constant
forward speed :math:`U`. The vehicle can be modeled as a single rigid body with
pitch centroidal moment of inertia :math:`I` and mass :math:`m`. Use an
inertial coordinate system with coordinate :math:`x` to measure the horizontal
travel and coordinate :math:`z` for the vertical travel. Use the standard of
positive :math:`z` pointing downwards. The front rotors are separated from the
rear rotors by distance :math:`a + b` and the mass center lies at distance
:math:`a` from the front rotor and distance :math:`b` from the rear rotor.

The mass center will have a velocity :math:`U` in the :math:`x` direction which
is constant and a variable velocity :math:`W` in the vertical direction. The
rigid body will have a pitch angle :math:`\theta` and a pitch angular velocity
:math:`q`.

The vehicle will have four forces acting on it. The two pairs of rotors produce
the thrust force :math:`F_f` at the front of the vehicle and the rotors at the
rear produce thrust force :math:`F_r`. The weight of the vehicle :math:`mg` is
the third force and the fourth force is the `drag force`_ acting perpendicular
to the quadcopter's body :math:`F_D` at the center of pressure (equal to
aerodynamic center in this case) which is equidistant from the to rotors. The
drag force should be modeled by the equation:

.. math::

   \DeclareMathOperator{\sgn}{sgn}
   F_D = \sgn{(v)} \frac{1}{2} \rho v^2 C_D A

.. _drag force: https://en.wikipedia.org/wiki/Drag_(physics)

This drag force will not affect motion in the :math:`x` direction since
:math:`U` is specified to be constant but you will need to determine its
contribution to resisting vertical motion. Make sure that the force is always
in the opposite direction of the component of :math:`\bar{v} = U \hat{x} + W
\hat{z}` that is perpendicular to the vehicle (same as :math:`F_D`) using the
`signum function`_, ``sign()`` in Matlab/Octave. Neglect any lift that may be
produced due to the vehicles angle of attack or body characteristics.

.. _signum function: https://en.wikipedia.org/wiki/Sign_function

.. topic:: What is :math:`v` in the drag equation?
   :class: alert alert-info

   :math:`v` in the equation for :math:`F_D` is the scalar component of
   velocity of the center of pressure (CoP) that is parallel to :math:`F_D`. If
   you write the velocity vector of the CoP in the body fixed reference frame
   you can get this component like we have for other body fixed velocity
   calculations.

.. figure:: https://objects-us-east-1.dream.io/eme134/2020s/lab-05-fig-01.png
   :width: 600px
   :align: center

   **Figure 1**: Schematics of the longitudinal quadcopter dynamics. The
   vectors are all drawn with a common sign convention, positive in the
   direction of the arrow.

Equations of Motion
-------------------

You will need to derive the equations of motion for this system. Using the
coordinates described above write the non-linear Newton-Euler equations. You
will be expected to show this work in your report. *Note: Use inertial
coordinates not body fixed for the derivation.* There will be two equations,
one for vertical deviation from equilibrium and one for pitch deviation from
equilibrium.

.. topic:: :math:`x` acceleration equation
   :class: alert alert-warning

   There is no acceleration in the :math:`x` direction so you do not write an
   equation for that coordinate. This is because we are imposing the assumption
   that the thrust is always the perfect amount to maintain constant forward
   speed irrespective of the pitch angle and thrust contributions from the
   rotors.

It will be useful to rewrite the two force magnitudes in terms of the total
force :math:`F_T = F_f + F_r` so that you can control :math:`F_T` to control
altitude and regulate :math:`F_f` for pitch control. Eliminate :math:`F_r` from
the two equations.

The state and input vectors would then be:

.. math::

   \bar{x} = & [z \quad \theta \quad w \quad q]^T \\
   \bar{u} = & [F_T \quad F_f]^T

The time varying variables are:

.. list-table::
   :class: table table-striped table-bordered
   :header-rows: 1

   * - Symbol
     - Description
     - Units
   * - :math:`z`
     - Vertical coordinate of the quadcopter's mass center
     - :math:`\textrm{m}`
   * - :math:`\theta`
     - Pitch angle.
     - :math:`\textrm{rad}`
   * - :math:`w=\dot{z}`
     - Vertical velocity
     - :math:`\textrm{m/s}`
   * - :math:`q=\dot{\theta}`
     - Pitch angular rate
     - :math:`\textrm{rad/s}`
   * - :math:`F_T`
     - Total thrust produced by the rotors
     - :math:`\textrm{N}`
   * - :math:`F_f`
     - Thrust produced by the front rotors
     - :math:`\textrm{N}`

You will need to formulate the equations of motion as four explicit linear
ordinary differential equations in first order form for your state derivative
function.

.. math::

   \dot{\bar{x}} = \bar{f}(\bar{x}, \bar{u}, t)

You will use the section `Defining the State Derivative Function
<https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#defining-the-state-derivative-function>`_
for these equations.

Inputs
------

The quadcopter will simply spin to its death as it falls to the ground without
any control. You will develop two Proportional-Integral-Derivative_ (PID)
controllers. One will be used to stabilize the vehicle in the pitch degree of
freedom and maintain level flight. The second will be used to maintain a
desired altitude. Your input function should return the two forces :math:`F_T`
and :math:`F_f`. The controllers take this form in the time domain:

.. math::

   F_T(t) & = k_{Tp} \left[z_d(t) - z(t)\right] +
              k_{Ti} \int_0^t \left[z_d(\tau) - z(\tau)\right]d\tau +
              k_{Td} \left[w_d(t) - w(t)\right] \\
   F_f(t) & = k_{fp} \left[\theta_d(t) - \theta(t)\right] +
              k_{fi} \int_0^t \left[\theta_d(\tau) - \theta(\tau)\right]d\tau +
              k_{fd} \left[q_d(t) - q(t)\right]

.. topic:: Derivative term
   :class: alert alert-info

   You may wonder why :math:`q` and :math:`w` are in the above equations.  Note
   that:

   .. math::

      k_{Td} \left[w_d(t) - w(t)\right] =
      k_{Td} \left[\frac{dz_d(t)}{d(t)} - \frac{dz(t)}{d(t)}\right]

.. _Proportional-Integral-Derivative: https://en.wikipedia.org/wiki/PID_controller

The PID controllers have three terms:

Proportional term
   Applies control that is proportional to the error: desired minus the actual.
   This term gives a spring-like effect to your controller, e.g. the larger the
   pitch angle is away from the desired the more force the controller applies
   to force the pitch angle to the desired angle :math:`\theta_d`.
Integral term
   Applies control that is proportional the integral of the error. This term is
   included to reduce or eliminate steady state error in the step response of
   the controlled system.
Derivative term
   Applies control that is proportional to the derivative of the error. This
   term provides a damping effect to the controlled variable which can control
   overshoot and even eliminate oscillation for a critically damped response.
   The desired rates should all be zero only desired coordinates need be set.

There are techniques to select PID gains for a known linear plant model that
have a desired step response. You have or will learn about these in EME 172.
You can also design a controller with manually tuning for a non-linear system
that has reasonable number of inputs and outputs, which we have with this drone
model. Watch the video below to get an idea of how one can systemically tune a
PID controller for desired performance by first trying P gains to get a stable
response, then D gains to reduce oscillations, and I gains to reduce steady
state error.

.. raw:: html

   <iframe width="560" height="315"
   src="https://www.youtube.com/embed/uXnDwojRb1g" frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope;
   picture-in-picture" allowfullscreen></iframe>

Once you have your systems simulating with no control (the drone should fall to
the ground spinning chaotically), follow these steps:

1. Set :math:`F_T` to a constant value. If you choose a value close to the
   weight of the vehicle the drone should have enough total force to try to
   approximately hover.
2. Set the desired pitch angle to a constant value :math:`\theta_d = \pi/180`
   so that you will get a step response for :math:`\theta`.
3. Apply the technique in the video to the control equation for :math:`F_f`.
   This should allow you to stabilize the quadcopter in pitch with a good
   response and it will either slowly fall or rise depending on the value you
   set :math:`F_T` to. Remember the sign convention of :math:`F_f` and that
   this is negative feedback to ensure you choose the right sign of the gains.
   The simulation only needs about 5 seconds of simulation time for the tuning
   process.
4. Set the :math:`F_f` gains to the ones you found in 3 and set the desired
   altitude to a constant value :math:`z_d = -1` so that you you will get a
   step response for :math:`z`. Set :math:`\theta_d = 0` for level flight.
5. Apply the technique in the video to the control equation for :math:`F_T`
   until you get a good step response for altitude :math:`z`.

.. topic:: Integral of the error
   :class: alert alert-info

   The proportional and derivative error terms are straight forward but how do
   you obtain the integral of the error?

   Recall that ``ode45`` integrates equations with respect to time. You need to
   integrate the error with respect to time from :math:`t=0` to the current
   time :math:`t` to obtain the cumulative error in the controller. To do so
   you can introduce two new state variables for the cumluative error
   :math:`\theta_c` and :math:`z_c`. Add these two state equations to your
   state derivative right hand side function like so:

   .. math::

      \dot{z_c}(t) & = \frac{d z_c(t)}{dt} = z_d(t) - z(t) \\
      \dot{\theta_c}(t) & = \frac{d \theta_c(t)}{dt} = \theta_d(t) - \theta(t)

   Note that the computed states are then the term you desire:

   .. math::

      z_c(t) & = \int_0^{t} \left[ z_d(\tau) - z(\tau) \right] d\tau \\
      \theta_c(t) & = \int_0^{t_i} \left[ \theta_d(\tau) - \theta(\tau) \right] d\tau

   If you can't get this part working you can still control the vehicle with
   two PD controllers, you'll just have stead state error.

Once you have selected all six gains and have good simultaneous step responses
for :math:`\theta` and :math:`z` you can now track an altitude "path" for a 20
second simulation. Setup your input function to have a desired altitude of:

.. math::

   z_d =
   \begin{cases}
      0 & 0 < t \leq 5 \\
      -0.25 & 5 < t \leq 10 \\
      -1.8 & 10 < t \leq 15 \\
      -1.0 & 15 < t \leq 20
   \end{cases}

Simulate the controlled system for this input and plot all the requested output
variables.

.. topic:: Plotting with z positive downward
   :class: alert alert-info

   For the plots that include :math:`z` and :math:`w` on the plot's ordinate
   axis it is helpful to reverse the axis so the negative values are above the
   positive values. To do so you can use this code after you call ``plot()``::

      h = gca;  % gets a handle to the most recent axis
      set(h, 'YDir', 'reverse');  % reverses the ordinate

See `Time Varying Inputs
<https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#time-varying-inputs>`_
for more information.

Constant Parameters
-------------------

The majority of the variables in the differential equations and input equations
above do not vary with time, i.e. they are constant. Below is a table with an
explanation of each variable, its value, and its units. Note that the units are
a self consistent set of SI base units.

.. list-table::
   :class: table table-striped table-bordered
   :header-rows: 1

   * - Symbol
     - Matlab variable
     - Description
     - Value
     - Units
   * - :math:`I`
     - ``I``
     - Centroidal pitch moment of inertia
     - Calculate and use the moment of inertia of a slender rod of mass
       :math:`m` and length :math:`a + b` with a mass center equidistant from
       the ends. You can find this in a moment of inerta table.
     - :math:`\textrm{kg}\cdot\textrm{m}^2`
   * - :math:`a`
     - ``a``
     - Distance from front rotor to mass center
     - 0.1
     - :math:`\textrm{m}`
   * - :math:`b`
     - ``b``
     - Distance from rear rotor to mass center
     - 0.2
     - :math:`\textrm{m}`
   * - :math:`g`
     - ``g``
     - Acceleration due to gravity
     - 9.81
     - :math:`\textrm{m/s}^2`
   * - :math:`m`
     - ``m``
     - Mass of the quadcopter
     - 1.0
     - :math:`\textrm{kg}`
   * - :math:`U`
     - ``U``
     - Forward speed of the quadcopter
     - 15
     - :math:`\textrm{m/s}`
   * - :math:`\rho`
     - ``rho``
     - Density of air
     - 1.225
     - :math:`\textrm{kg}/m^s`
   * - :math:`A`
     - ``A``
     - Top view area of the quadcopter
     - Assume a square shape
     - :math:`\textrm{m}^2`
   * - :math:`C_D`
     - ``CD``
     - Drag coefficient
     - 0.1
     - Unitless
   * - :math:`k_{fp}`
     - ``kfp``
     - Front rotor force proportional control gain
     - Determined by you
     - :math:`\textrm{N/rad}`
   * - :math:`k_{fi}`
     - ``kfi``
     - Front rotor force integral control gain
     - Determined by you
     - :math:`\textrm{N/rad/s}`
   * - :math:`k_{fd}`
     - ``kfd``
     - Front rotor force derivative control gain
     - Determined by you
     - :math:`\textrm{Ns/rad}`
   * - :math:`k_{Tp}`
     - ``kTp``
     - Total rotor force proportional control gain
     - Determined by you
     - :math:`\textrm{N/rad}`
   * - :math:`k_{Ti}`
     - ``kTi``
     - Total rotor force integral control gain
     - Determined by you
     - :math:`\textrm{N/rad/s}`
   * - :math:`k_{Td}`
     - ``kTd``
     - Total rotor force derivative control gain
     - Determined by you
     - :math:`\textrm{Ns/rad}`

You will use the section `Integrating the Equations
<https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#integrating-the-equations>`_
to for these values.

Outputs
-------

The output function should return all six of the state variables, the travel
distance :math:`x`, the two rotor forces :math:`F_f,F_r`, and the desired
altitude :math:`z_d`. Include these ten time varying variables in your
simulation plots. You will use the section `Outputs Other Than The States
<https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#outputs-other-than-the-states>`_
to compute these values.

Initial Conditions
==================

For the simulations, set the initial conditions all to zero.

See `Integrating the Equations
<https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#integrating-the-equations>`_
for how to set up the initial condition vector. Make sure that your initial
conditions are arranged in the same order as your state variables.

Time Steps
==========

Simulate the system for 20 seconds with time steps of 1/20th of a second for
all simulations.

Animation
=========

The following function |animate_drone|_ function will create an animation of
your drone flight simulation. You can use this to visualize the simulation and
assess the controller's performance.

.. code-include:: ../scripts/animate_drone.m
   :lexer: matlab

.. |animate_drone| replace:: ``animate_drone.m``
.. _animate_drone: {filename}/scripts/animate_drone.m

Deliverables
============

In your lab report, show your work for creating and evaluating the simulation
model. Include any calculations you had to do, for example those for state
equations, initial conditions, input equations, time parameters, and any other
parameters. Additionally, provide the indicated plots and answer the questions
below. Append a copy of your Matlab/Octave code to the end of the report. The
report should follow the `report template and guidelines
<{filename}/pages/report-template.rst>`_.

Submit a report as a single PDF file to Canvas by the due date that addresses
the following items:

1. Create a function defined in an m-file that evaluates the right hand side of
   the ODEs, i.e. evaluates the state derivatives. See `Defining the State
   Derivative Function`_ for an explanation.
2. Create one function defined in an m-file that calculates the control input.
   See `Time Varying Inputs`_ for an explanation.
3. Create a function defined in an m-file that calculates the requested
   outputs. See `Outputs Other Than the States`_  and `Outputs Involving State
   Derivatives`_ for an explanation.
4. Create a script in an m-file that utilizes the above functions to simulate
   system for the final path tracking simulation. This should setup the
   constants, integrate the dynamics equations, and plot each state, and output
   versus time. See `Integrating the Equations`_ for an explanation.
5. Derive the equations of motion of the system. Include your derivation in the
   report and the resulting equations.
6. Develop two PID feedback controllers using manual tuning. You should try to
   minimize steady state error, oscillations, the time constant, and overshoot
   in that order of importance for both the altitude tracking and the pitch
   stabilization. Show time history plots of the step responses for pitch and
   altitude using your final gain selection.
7. Present a single controlled simulation of the vehicle and explain the
   behaviors you observe in each of the ten output variables using knowledge
   and principles you have learned in the class.

.. _Outputs Involving State Derivatives: https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#outputs-involving-state-derivatives

Assessment Rubric
=================

.. list-table:: Score will be between 30 and 100.
   :class: table table-striped table-bordered
   :header-rows: 1

   * - Topic
     - [10 pts] Exceeds expectations
     - [5 pts] Meets expectatoins
     - [0 pts] Does not meet expectations
   * - Functions
     - All Matlab/Octave functions are present and take correct inputs and
       produce the expected outputs.
     - Some of the functions are present and mostly take correct inputs and
       produce the expected outputs
     - No functions are present or not working at all.
   * - Main Script
     - Constant parameters only defined once in main script(s);
       Integration produces the correct state, input, and output trajectories;
       Good choices in number of time steps and resolution are chosen and
       justified; Intermediate calculations present and functioning.
     - Parameters are defined in multiple places; Integration produces some
       correct state, input, and output trajectories; Poor choices in number of
       time steps and resolution are chosen; Intermediate calculations mostly
       present and functioning.
     - Constants defined redundantly; Integration produces incorrect
       trajectories; Poor choices in time duration and steps; Intermediate
       calculations not present or functioning.
   * - Equations of Motion
     - Derviation of equations is presented and the correct nonlinear equations
       are shown.
     - Derviation of equations is presented and the nonlinear equations are
       mostly correct.
     - Derviation of equations is not present and the nonlinear equations are
       incorrect.
   * - Pitch Control
     - PID controller working that stabilizes the pitch angle during manuerving
       and has ideal control behavior in terms of steady state error,
       oscillations, time constant, and overshoot. Step response plots included
       that demonstrate this.
     - PID or PD controller working that stabilizes the pitch angle during
       manuerving and has moderately good control behavior in terms of steady
       state error, oscillations, time constant, and overshoot. Step response
       plots included that demonstrate this.
     - Pitch controller not present or functioning in any way. Step response
       plots not included.
   * - Altitude Tracking Control
     - PID controller working that stabilizes the pitch angle during manuerving
       and has ideal control behavior in terms of steady state error,
       oscillations, time constant, and overshoot. Step response plots included
       that demonstrate this.
     - PID or PD controller working that stabilizes the pitch angle during
       manuerving and has moderately good control behavior in terms of steady
       state error, oscillations, time constant, and overshoot. Step response
       plots included that demonstrate this.
     - Altitude controller not present or functioning in any way. Step response
       plots not included.
   * - Report and Code Formatting
     - All axes labeled with units, legible font sizes, informative captions;
       Functions are documented with docstrings which fully explain the inputs
       and outputs; Professional, very legible, quality writing; All report
       format requirements met
     - Some axes labeled with units, mostly legible font sizes,
       less-than-informative captions; Functions have docstrings but the inputs
       and outputs are not fully explained; Semi-professional, somewhat
       legible, writing needs improvement; Most report format requirements met
     - Axes do not have labels, legible font sizes, or informative captions;
       Functions do not have docstrings; Report is not professionally written
       and formatted; Report format requirements are not met
   * - Contributions
     - Clear that all team members have made equitable contributions.
     - Not clear that contributions were equitable and you need to improve
       balance of contributions.
     - No indication of equitable contributions.
