:title: Lab 2: Dragster Traction Control
:status: hidden
:slug: lab-02

.. contents::

Learning Objectives
===================

After completing this lab you will be able to:

- formulate the explicit first order ordinary differential equations for the
  longitudinal dynamics of a drag racing car
- translate ordinary differential equations into a computer function that
  evaluates the equations at any given point in time
- develop a function that evaluates state dependent input functions
- numerically integrate ordinary differential equations with Octave/Matlab's
  ode45_
- implement and tune a longitudinal traction control system
- create complete and legible plots of the resulting input, state, and output
  trajectories
- create a report with textual explanations and plots of the simulation

.. _ode45: https://www.mathworks.com/help/matlab/ref/ode45.html

.. topic:: Information
   :class: alert alert-info

   Extra information (asides) are in blue boxes.

.. topic:: Warnings
   :class: alert alert-warning

   Warnings are in yellow boxes.

Introduction
============

In this lab, you will investigate the longitudinal dynamics of a car in a `drag
race`_ in which the motion is governed by a model of longitudinal `tire slip`_.
This drag race is a little special because it has a patch of ice part way down
the track. You will explore the performance on this partially slippery track
and then add a simple traction control system to attempt to improve
performance.

.. _drag race: https://en.wikipedia.org/wiki/Drag_racing
.. _tire slip: https://en.wikipedia.org/wiki/Slip_(vehicle_dynamics)

This is a video of a variety of cars in typical drag races:

.. raw:: html

   <iframe width="560" height="315"
   src="https://www.youtube.com/embed/rw3LE78gwhg" frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope;
   picture-in-picture" allowfullscreen></iframe>

Watch the car tires carefully and notice the large deformations that occur.
This is a contributor to "tire slip".

System Description
==================

A car accelerating along flat ground can be reasonably modeled by the coupled
dynamics of a particle with the mass of the car :math:`m` that is pushed along
by a propulsive force and is resisted by a force that models `air drag`_. The
propulsive force is arrived at by modeling a single wheel which has a spin
moment of inertia :math:`I` equivalent to the four wheels, bearing friction
:math:`\tau_B`, wheel-ground contact friction :math:`F_f`, and an applied
torque :math:`\tau` arising from an idealized drivetrain. The propulsive force
is then equal in magnitude to the friction force generated at the wheel-ground
contact. Figure 1 provides a free body diagram of the system.

.. _air drag: https://en.wikipedia.org/wiki/Drag_(physics)

.. figure:: https://objects-us-east-1.dream.io/eme134/2020s/lab-02-fig-01.png
   :width: 400px
   :align: center

   **Figure 1**: Schematics of the longitudinal car dynamics model.

The particle representing the car only has forward motion and its position is
tracked by the time varying variable :math:`x` as wells as its velocity
:math:`v=\dot{x}`. The drag due to air resistance can be modeled by the drag
equation:

.. math::

   F_D = \frac{1}{2} \rho C_D A v^2

The wheel can be modeled as a rotating disc with a radius equal to the
effective *rolling radius* of the cars' tires :math:`r`. The rotational
acceleration of the wheel is increased by an ideal applied torque
:math:`\tau_D` from the drivetrain. The rotational motion is resisted by
bearing friction; modeled with a simple viscous damping model where :math:`b`
is the damping coefficient:

.. math::

   \tau_B = b \omega

Lastly, there is a torque generated by the ground friction:

.. math::

   \tau_F = F_f r

The friction force :math:`F_f` can be modeled by a Coulomb-like equation which
has a coefficient of friction :math:`\mu` that varies with the drive slip ratio
:math:`s_D` and is proportional to the normal force :math:`F_N` (the car's
total weight in this case).

.. math::

   F_f = \mu(s_D) F_N

Equations of Motion
-------------------

You will need to form Newton's Second Law and write it as two first order ODEs
for the particle representing the car's longitudinal motion:

.. math::

   m\dot{v} & = \sum F \\
   \dot{x} & = v

Next you will need to form Euler's Second Law for the wheel:

.. math::

   I\dot{\omega} & = \sum \tau \\
   \dot{\theta} & = \omega

**Make sure that you have correct signs on the elements of each summation
above.**

These can be written as four first order explicit ordinary differential
equations:

.. math::

   \dot{x} & = \textrm{?} \\
   \dot{v} & = \textrm{?} \\
   \dot{\theta} & = \textrm{?} \\
   \dot{\omega} & =\textrm{?}

These equations define expressions for the derivatives of the four time varying
state variables :math:`x,v,\theta,\omega` which are described below.

.. list-table::
   :class: table table-striped table-bordered
   :header-rows: 1

   * - Symbol
     - Description
     - Units
   * - :math:`x`
     - Longitudinal distance of the car
     - :math:`\textrm{m}`
   * - :math:`v`
     - Longitudinal velocity of the car
     - :math:`\textrm{m/s}`
   * - :math:`\theta`
     - Angle of the car's wheel
     - :math:`\textrm{rad}`
   * - :math:`\omega`
     - Angular rate of the car's wheel
     - :math:`\textrm{rad/s}`

You will use the section `Defining the State Derivative Function
<https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#defining-the-state-derivative-function>`_
for these equations.

Inputs
------

The friction force :math:`F_f` and the driving torque :math:`\tau_D` should be
treated as inputs to the above equations of motion. These input equations
should be defined in a input function. See `Time Varying Inputs
<https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#time-varying-inputs>`_
for more information. The inputs function should take in the time, current
state, and constants structure and produce a vector with :math:`\tau_D`,
:math:`F_f`, :math:`s_D`, and :math:`\mu`.

Friction
~~~~~~~~

The driving slip ratio :math:`s_D` characterizes the actual forward velocity
relative to the ideal pure rolling velocity and is defined as:

.. math::

   s_D = 1 - \frac{v}{\omega r}

If :math:`v = \omega r` there is no slip, i.e. pure rolling. If :math:`v <
\omega r` there is slip and the car does not advance as fast as it would if
there were pure rolling. If :math:`s_D \geq 1` the wheel is purely sliding on
the ground (a burnout with no forward propulsion)

The longitudinal coefficient of friction :math:`\mu` is a function of the slip
ratio. This relationship is empirically derived for different tires and ground
surface types. A mathematical model that does a good job at describing this
relationship is:

.. math::

   \mu(s_D) = A[B(1 - e^{-C s_D}) - D s_D]

where :math:`A,B,C,D` are the coefficients that characterize the model's best
fit to the empirical data. You are provided values for a typical tire on dry
concrete and a typical tire on icy concrete in the "Constant Parameters"
section below. **Figure 2** shows the basic shape of these functions for dry
concrete and icy concrete.

.. figure:: https://objects-us-east-1.dream.io/eme134/2020s/lab-02-fig-02.png
   :width: 600px
   :align: center

   **Figure 2**: Typical relationship between the slip ratio and the
   coefficient of friction.

The race track will be 200 m long with a patch of ice between the 50 m and 100
m marks. You'll need to switch between the two sets of friction equation
coefficients at the boundaries between dry and icy. You may be inclined to
switch between these two conditions instantly, but numerical integration
routines like ``ode45`` are designed to work with continuous functions, so the
switch between dry and ice and back will need to be a smooth transition. The
`logistic function`_ provides a nice way to smoothly transition between two
values. Below are the equations to calculate the coefficient values for any
value of :math:`x`. You'll need to implement these using some form of control
flow like an if-else or switch statement for each of the coefficients
:math:`A,B,C,D`.

.. figure:: https://objects-us-east-1.dream.io/eme134/2020s/lab-02-fig-03.png
   :width: 600px
   :align: center

   **Figure 3**: Use of the logistic function for a smooth transition between
   the coefficients.

The following shows the piecewise function for :math:`A`:

.. math::

   A =
   \begin{cases}
      A_{dry} & x \leq 45 \\
      \frac{A_{ice} - A_{dry}}{1 + e^{-5(x-47.5)}} + A_{dry} & 45 < x \leq 50 \\
      A_{ice} & 50 < x \leq 100 \\
      \frac{A_{dry} - A_{ice}}{1 + e^{-5(x-102.5)}} + A_{ice} & 100 < x \leq 105 \\
      A_{dry} & x > 105
   \end{cases}

.. _logistic function: https://en.wikipedia.org/wiki/Logistic_function

Driving torque
~~~~~~~~~~~~~~

For the driving :math:`\tau_D` you should consider two cases: without traction
control and with traction control.

In the without traction control case, :math:`\tau_D` should computed assuming
the input power is a constant and always at its maximum :math:`P_{max}`. This
assumes that the car's transmission is ideal and is always at the right gear
ratio to operate at the engine's peak power output. :math:`\tau_D` should then
be governed by the current angular rate of the wheels :math:`\omega`. This
models "flooring" the gas pedal and shifting the transmission perfectly to
always maintain maximum power to the wheels.

.. math::

   \tau_D = \frac{P_{max}}{\omega}

For the traction control case, you will implement a simple proportional
feedback traction control system that governs the torque by assuming you can
measure the slip ratio and can calculate the error between it and a desired
value :math:`s_{D peak} - s_D`. The driving torque will then be set to a gain
:math:`k` multiplied by the error. Thus torque will be increased with the error
is growing and decreased when shrinking.

.. math::

   \tau_D = k(s_{D peak} - s_D)

You'll need to determine the slip ratio that corresponds to the maximum
coefficient of friction for the dry and icy conditions and use that for
:math:`s_{D peak}`. The gain :math:`k` should be a positive value. You'll need
to try different values to home in on the best performance for your car.
Inspect the :math:`\mu` and :math:`s_D` curves versus time to see if this is
behaving as expected. Also, the value of :math:`\tau_D` produced by the
controller should never cause the input power to be higher than
:math:`P_{max}`. So always take the minimum of :math:`\tau_D` in the without
control case vs. the with control case to stay under the maximum power limit.
In other words, the controller can't draw more power than :math:`P_{max}`.

Outputs
-------

Your outputs should include all of the state trajectories and include the
trajectories of the time varying slip ratio, coefficient of friction, driving
torque, and friction force which have been computed already above in the state
derivative and input functions. Additionally, compute the total energy consumed
in traversing the 200 meter race distance. The time rate of change of the input
energy is the input power which is related to the torque applied to the wheels
and the angular rate of the wheels:

.. math::

   \dot{E}_{in} = P_{in} = \tau_D \omega

The input energy can be added as a fifth state variable to recover the total
accumulated energy consumed. The trajectory of the power should also be added
as an output variable.

You will use the section `Outputs Other Than The States
<https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#outputs-other-than-the-states>`_
to compute these values. The outputs function should take in the time, current
state, input function handle, and constants structure and produce a vector with
:math:`\tau_D`, :math:`F_f`, :math:`s_D`, :math:`\mu`, :math:`P_{in}`.

Constant Parameters
-------------------

The majority of the variables in the five differential equations and input
equations above do not vary with time, i.e. they are constant. Below is a table
with an explanation of each variable, its value, and its units. Note that the
units are a self consistent set of SI base units.

.. list-table::
   :class: table table-striped table-bordered
   :header-rows: 1

   * - Symbol
     - Description
     - Value
     - Units
   * - :math:`A`
     - Car frontal area
     - :math:`0.5`
     - :math:`\textrm{m}^2`
   * - :math:`C_D`
     - Car drag coefficient
     - :math:`0.7`
     - :math:`\textrm{unitless}`
   * - :math:`I`
     - Combined spin moment of inerta of all four wheels
     - 2.0
     - :math:`\textrm{kg}\cdot\textrm{m}^2`
   * - :math:`P_{max}`
     - Maximum power available at the driveshaft
     - 745000
     - :math:`\textrm{W}`
   * - :math:`b`
     - Wheel viscous coefficient
     - 30.0
     - :math:`\textrm{N}\cdot\textrm{m}\cdot\textrm{s}`
   * - :math:`g`
     - Acceleration due to gravity
     - 9.81
     - :math:`\textrm{m/s}^2`
   * - :math:`k`
     - Traction controller proportional gain
     - ?
     - :math:`\textrm{N}\cdot\textrm{m}`
   * - :math:`m`
     - Mass of the car
     - 1000
     - :math:`\textrm{kg}`
   * - :math:`r`
     - Radius of the wheel
     - 0.2
     - :math:`\textrm{m}`
   * - :math:`\rho`
     - Density of air
     - 1.225
     - :math:`\textrm{kg/m}^3`
   * - :math:`A_{dry}`
     - Coefficient for friction equation
     - 0.9
     - NA
   * - :math:`B_{dry}`
     - Coefficient for friction equation
     - 1.07
     - NA
   * - :math:`C_{dry}`
     - Coefficient for friction equation
     - 28
     - NA
   * - :math:`D_{dry}`
     - Coefficient for friction equation
     - 0.3
     - NA
   * - :math:`A_{ice}`
     - Coefficient for friction equation
     - 0.1
     - NA
   * - :math:`B_{ice}`
     - Coefficient for friction equation
     - 1.07
     - NA
   * - :math:`C_{ice}`
     - Coefficient for friction equation
     - 38
     - NA
   * - :math:`D_{ice}`
     - Coefficient for friction equation
     - 0.7
     - NA

You will use the section `Integrating the Equations
<https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#integrating-the-equations>`_
to for these values.

Initial Conditions
==================

Start the car with an initial forward speed of 1 m/s (a rolling start) and set
the wheel angular rate such that the wheel is purely rolling with no slip. All
other states can be initialized as zero. See `Integrating the Equations
<https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html#integrating-the-equations>`_
for how to set up the initial condition vector. Make sure that your initial
conditions are arranged in the same order as your state variables.

Time Steps
==========

Simulate the system for 10 seconds with time steps of 1/100th of a second. If
your simulation is working with the provided constants you should see just over
300 meters of travel in 10 seconds.

Deliverables
============

In your lab report, show your work for creating and evaluating the simulation
model. Include any calculations you had to do, for example those for state
equations, initial conditions, input equations, time parameters, and any other
parameters.  Additionally, provide the indicated plots and answer the questions
below.  Append a copy of your Matlab/Octave code to the end of the report. The
report should follow the `report template and guidelines
<{filename}/pages/report-template.rst>`_.

Submit a report as a single PDF file to Canvas by the due date that addresses
the following items:

1. Create a function defined in an m-file that evaluates the right hand side of
   the ODEs, i.e. evaluates the state derivatives. See `Defining the State
   Derivative Function`_ for an explanation.
2. Create two functions defined each in an m-file that calculates the two
   requested inputs: with and without traction control. See `Time Varying
   Inputs`_ for an explanation.
3. Create a function defined in an m-file that calculates the requested
   outputs. See `Outputs Other Than the States`_ for an explanation.
4. Create a script in an m-file that utilizes the above functions to
   simulate system for the two scenarios: with and without traction control.
   This should setup the constants, integrate the dynamics equations, and plot
   each state, and output versus time. See `Integrating the Equations`_ for an
   explanation.
5. Make a plot of the coefficients of friction versus slip ratio which includes
   the curves for the dry and icy conditions. Indicate what slip ratios were
   chosen for the peak traction.
6. Make plots of the outputs versus time of the scenario without traction
   control and explain why you think the simulation is behaving realistically
   or unrealistically.
7. Make plots to compare outputs versus time between the two scenarios: with
   and without traction control. Plotting the each trajectory on its own or in
   subplots with one color line for each scenario.
8. Report the time to the 200 m mark for each scenario and discuss the results
   and explain why the vehicle that wins won. Report the input energy consumed
   at the 200 m mark and discuss the differences in energy consumption, why it
   is, and what the implications are. You can present the joules of energy in
   equivalent liters of gasoline to help get a idea of the quantity.

Tips
====

Make sure to construct the simulation in stages. Here is a good path:

1. Create the state derivatives function.
2. Create the inputs function with no traction control and no ice.
3. Test the simulation till you are confident it is producing realistic
   results.
4. Add ice to the input function. Test the simulation until it seems to be
   working.
5. Create another input function with only control, no ice. Test the
   simulation until it seems to be working.
6. Add both ice and control to the input function in 5. Test the simulation
   until it seems to be working.
7. Create an outputs function and make your final plots.


Assessment Rubric
=================

.. list-table:: Score will be between 50 and 100.
   :class: table table-striped table-bordered
   :header-rows: 1

   * - Topic
     - [10 pts] Exceeds expectations
     - [5 pts] Meets expectatoins
     - [0 pts] Does not meet expectations
   * - Functions
     - All Matlab/Octave functions are present and take correct inputs and
       produce the expected outputs.
     - Some of the functions are present and mostly take correct inputs and
       produce the expected outputs
     - No functions are present or not working at all.
   * - Main Script
     - Constant parameters only defined once in main script(s);
       Integration produces the correct state, input, and output trajectories;
       Good choices in number of time steps and resolution are chosen and
       justified.
     - Parameters are defined in multiple places; Integration produces some
       correct state, input, and output trajectories; Poor choices in number of
       time steps and resolution are chosen
     - Constants defined redundantly; Integration produces incorrect
       trajectories; Poor choices in time duration and steps
   * - Explanations
     - Explanation of two simulation comparisons are correct and well
       explained; Plots of appropriate variables are used in the explanations
     - Explanation of two simulation comparisons is somewhat correct and
       reasonably explained; Plots of appropriate variables are used in the
       explanations, but some are missing
     - Explanation of two simulations are incorrect and poorly explained; Plots
       are missing
   * - Report and Code Formatting
     - All axes labeled with units, legible font sizes, informative captions;
       Functions are documented with docstrings which fully explain the inputs
       and outputs; Professional, very legible, quality writing; All report
       format requirements met
     - Some axes labeled with units, mostly legible font sizes,
       less-than-informative captions; Functions have docstrings but the inputs
       and outputs are not fully explained; Semi-professional, somewhat
       legible, writing needs improvement; Most report format requirements met
     - Axes do not have labels, legible font sizes, or informative captions;
       Functions do not have docstrings; Report is not professionally written
       and formatted; Report format requirements are not met
   * - Contributions
     - Clear that all team members have made equitable contributions.
     - Not clear that contributions were equitable and you need to improve
       balance of contributions.
     - No indication of equitable contributions.
